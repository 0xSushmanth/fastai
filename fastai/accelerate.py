# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/20b_accelerate.ipynb (unless otherwise specified).

__all__ = ['AcceleratedTrainer']

# Cell
#nbdev_comment from __future__ import annotations
from .basics import *
from .callback.progress import ProgressCallback
from .distributed import DistributedDL, rank0_first, setup_distrib, teardown_distrib
from .optimizer import OptimWrapper
from accelerate import Accelerator

# Cell
_hidden_params = ["mixed_precision", "fp16", "log_with", "logging_dir", "step_scheduler_with_optimizer"]

# Cell
class AcceleratedTrainer(Callback):
    "Wrap `model` in `DistributedDataParallel` and `dls` in `DistributedDL` to be used in the Accelerate framework"
    order = 11
    @delegates(Accelerator, but=_hidden_params)
    def __init__(self,
        sync_bn=True, # Whether to replace all batch norm with `nn.SyncBatchNorm`
        **kwargs
    ):
        store_attr()
        self.accelerator = Accelerator(**kwargs)
    def before_fit(self):
        self.learn.model = self.accelerator.prepare(
            nn.SyncBatchNorm.convert_sync_batchnorm(self.model) if self.sync_bn else self.model
        )
        self.old_dls, self.old_opt = list(self.dls), self.opt
        self.learn.dls.loaders = [self._wrap_dl(dl) for dl in self.dls]
        if rank_distrib(): self.learn.logger=noop

    def _wrap_dl(self, dl):
        return dl if isinstance(dl,DistributedDL) else DistributedDL(dl)

    def before_backward(self):
        # Apply Accelerator backward which handles DeepSpeed, otherwise will call loss_grad.backward()
        self.accelerator.backward(self.learn.loss_grad)
        raise CancelBackwardException()

    def before_train(self):    self.learn.dl = self._wrap_dl(self.learn.dl)
    def before_validate(self): self.learn.dl = self._wrap_dl(self.learn.dl)
    def after_fit(self): self.learn.model,self.learn.dls.loaders = self.learn.model.module,self.old_dls

# Cell
@patch
@delegates(Accelerator, but=_hidden_params)
def to_accelerate(self: Learner,
        sync_bn=True, # Whether to replace all batch norm with `nn.SyncBatchNorm`
        **kwargs
    ):
    "Add `AcceleratedTrainer` to a learner, and configures an Accelerator"
    self.add_cb(AcceleratedTrainer(sync_bn, **kwargs))
    if rank_distrib(): self.remove_cb(ProgressCallback)
    return self

# Cell
@patch
def detach_accelerate(self: Learner):
    "Remove `DistributedTrainer` from a learner"
    if num_distrib() <=1: return self
    self.remove_cb(AcceleratedTrainer)
    if rank_distrib() and not hasattr(self, 'progress'): self.add_cb(ProgressCallback())
    return self

# Cell
@patch
@contextmanager
@delegates(Accelerator, but=_hidden_params)
def accelerate_ctx(self: Learner,
        sync_bn=True, # Whether to replace all batch norm with `nn.SyncBatchNorm`
        in_notebook=False, # Whether we are launching from a notebook or not
        **kwargs
   ):
    "A context manager to adapt a learner to train in distributed data parallel mode."
    # Adapt self to DistributedDataParallel, yield, and cleanup afterwards.
    cleanup_dpg = False
    try:
        if in_notebook:
            cuda_id = rank_distrib()
            if not torch.distributed.is_initialized():
                setup_distrib(cuda_id)
                cleanup_dpg = torch.distributed.is_initialized()
            if not rank_distrib(): print("Training Learner...")
        if num_distrib(): self.to_accelerate(sync_bn, **kwargs)
        yield self
    finally:
        self.detach_accelerate()
        if cleanup_dpg: teardown_distrib()